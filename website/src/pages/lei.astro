---
import BaseLayout from "../layouts/BaseLayout.astro";
import ThoughtCard from "../components/ThoughtCard.astro";
import Heatmap from "../components/Heatmap.astro";
import TimelineScroll from "../components/TimelineScroll.astro";
import thoughts from "../data/thoughts.json";
import dailyCounts from "../data/daily-counts.json";

// PERFORMANCE OPTIMIZATION:
// Only render initial batch on SSR to reduce HTML size and parse time
const INITIAL_RENDER_COUNT = 20; // First 20 thoughts rendered on server
const INITIAL_AUTH_LIMIT = 30; // For unauthenticated users
const initialThoughts = thoughts.slice(0, INITIAL_RENDER_COUNT);
const limitedThoughts = thoughts.slice(0, INITIAL_AUTH_LIMIT);
---

<BaseLayout title="Thoughts">
  <div id="auth-loading" class="auth-state">
    <div class="spinner"></div>
  </div>

  <div id="content" class="auth-state hidden">
    <div class="container">
      <TimelineScroll thoughts={thoughts as any} />
      <main class="main-content">
        <section class="hero">
          <a href="/" class="back-link">
            <span class="material-symbols-outlined">arrow_back</span>
            Back to Home
          </a>
          <h1>My Thoughts</h1>
          <p class="hero-subtitle text-muted">
            A collection of ideas, insights, and moments from across the web.
          </p>
          <div id="auth-notice" class="auth-notice hidden">
            <p>üîí Showing limited content. Sign in to view all thoughts.</p>
          </div>
        </section>

        <section class="activity-section">
          <!-- Heatmap loads its data from data attribute -->
          <Heatmap data={dailyCounts} />
        </section>

        <section class="timeline-section">
          <div class="timeline-header flex-between">
            <h2 class="section-title">Recent Thoughts</h2>
            <div id="filter-indicator" class="filter-badge hidden">
              <span id="filter-date-text"></span>
              <button id="clear-filter" class="material-symbols-outlined"
                >close</button
              >
            </div>
          </div>

          {
            thoughts.length === 0 ? (
              <div class="empty-state">
                <span class="empty-icon">üìù</span>
                <p>No thoughts yet</p>
                <p class="text-small text-muted">
                  Start collecting from X.com, Bilibili, or other supported platforms
                </p>
              </div>
            ) : (
              <>
                {/* Initial render - All users see the same initial batch */}
                <div class="timeline" id="thoughts-timeline">
                  {initialThoughts.map((thought) => (
                    <ThoughtCard thought={thought as any} />
                  ))}
                </div>
                
                {/* Loading indicator for lazy loading */}
                <div id="loading-indicator" class="loading-indicator hidden">
                  <div class="spinner-small"></div>
                  <span>Loading more thoughts...</span>
                </div>
                
                {/* Sentinel element for intersection observer */}
                <div id="load-more-sentinel" class="load-more-sentinel"></div>
              </>
            )
          }

          <div id="content-limit-notice" class="content-limit-notice hidden">
            <div class="limit-notice-content">
              <span class="material-symbols-outlined limit-icon">lock</span>
              <h3>You've reached the preview limit</h3>
              <p>Sign in to unlock all <strong>{thoughts.length}</strong> thoughts and get full access to your collection.</p>
              <button id="sign-in-btn" class="btn btn-auth">
                <span class="material-symbols-outlined">login</span>
                <span>Sign In to Continue</span>
              </button>
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>
</BaseLayout>

<script>
  import { auth } from "../lib/firebase";
  import { onAuthStateChanged } from "firebase/auth";

  // Import thoughts data for client-side rendering
  import thoughtsData from "../data/thoughts.json";

  const loading = document.getElementById("auth-loading");
  const content = document.getElementById("content");
  const authNotice = document.getElementById("auth-notice");
  const timeline = document.getElementById("thoughts-timeline");
  const contentLimitNotice = document.getElementById("content-limit-notice");
  const signInBtn = document.getElementById("sign-in-btn");
  const loadingIndicator = document.getElementById("loading-indicator");
  const sentinel = document.getElementById("load-more-sentinel");

  // Lazy loading state
  const BATCH_SIZE = 20;
  const INITIAL_RENDER = 20;
  const AUTH_LIMIT = 30;
  let currentIndex = INITIAL_RENDER;
  let isAuthenticated = false;
  let isLoading = false;
  let hasReachedLimit = false;

  // Create ThoughtCard HTML from thought data
  function createThoughtCardHTML(thought: any): string {
    const sourceClass = thought.source.toLowerCase();
    const formattedDate = new Date(thought.originalDate).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
    const dateISO = thought.originalDate.split("T")[0];

    const mediaHTML = (thought.images.length > 0 || thought.videos.length > 0) 
      ? `<div class="card-media">
          ${thought.images.map((img: string) => `<img src="${img}" alt="" loading="lazy" />`).join('')}
          ${thought.videos.map((vid: string) => `<video src="${vid}" controls preload="none"></video>`).join('')}
        </div>`
      : '';

    const tagsHTML = thought.tags.length > 0
      ? `<div class="card-tags">
          ${thought.tags.map((tag: string) => `<span class="tag">${tag}</span>`).join('')}
        </div>`
      : '';

    const originalLinkHTML = thought.originalUrl && thought.originalUrl.startsWith('https://')
      ? `<a href="${thought.originalUrl}" target="_blank" rel="noopener" class="original-link">View original ‚Üí</a>`
      : '';

    return `
      <article class="thought-card" data-date="${dateISO}">
        <header class="card-header">
          <span class="badge ${sourceClass}">${thought.source}</span>
          <time datetime="${thought.originalDate}" class="text-muted text-small">
            ${formattedDate}
          </time>
        </header>
        <div class="card-content">
          <p>${thought.content}</p>
          ${mediaHTML}
        </div>
        <footer class="card-footer">
          ${tagsHTML}
          ${originalLinkHTML}
        </footer>
      </article>
    `;
  }

  // Load more thoughts
  function loadMoreThoughts() {
    if (isLoading || hasReachedLimit) return;

    const maxIndex = isAuthenticated ? thoughtsData.length : AUTH_LIMIT;
    
    if (currentIndex >= maxIndex) {
      hasReachedLimit = true;
      sentinel?.classList.add('hidden');
      
      // Show auth notice for unauthenticated users
      if (!isAuthenticated && currentIndex >= AUTH_LIMIT) {
        contentLimitNotice?.classList.remove('hidden');
      }
      return;
    }

    isLoading = true;
    loadingIndicator?.classList.remove('hidden');

    // Simulate network delay for better UX (can be removed in production)
    setTimeout(() => {
      const endIndex = Math.min(currentIndex + BATCH_SIZE, maxIndex);
      const batch = thoughtsData.slice(currentIndex, endIndex);

      batch.forEach((thought) => {
        const cardHTML = createThoughtCardHTML(thought);
        timeline?.insertAdjacentHTML('beforeend', cardHTML);
      });

      currentIndex = endIndex;
      isLoading = false;
      loadingIndicator?.classList.add('hidden');

      // Check if we've reached the limit
      if (currentIndex >= maxIndex) {
        hasReachedLimit = true;
        sentinel?.classList.add('hidden');
        
        if (!isAuthenticated && currentIndex >= AUTH_LIMIT) {
          contentLimitNotice?.classList.remove('hidden');
        }
      }
    }, 300);
  }

  // Intersection Observer for infinite scroll
  const observerOptions = {
    root: null,
    rootMargin: '200px', // Start loading 200px before sentinel
    threshold: 0
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        loadMoreThoughts();
      }
    });
  }, observerOptions);

  // Auth state handler
  onAuthStateChanged(auth, (user) => {
    loading?.classList.add("hidden");
    content?.classList.remove("hidden");
    
    isAuthenticated = !!user;
    
    if (user) {
      // Authenticated: can load all thoughts
      authNotice?.classList.add("hidden");
      contentLimitNotice?.classList.add("hidden");
      hasReachedLimit = false;
      sentinel?.classList.remove('hidden');
      
      // Start observing for lazy loading
      if (sentinel) {
        observer.observe(sentinel);
      }
    } else {
      // Unauthenticated: limited access
      authNotice?.classList.remove("hidden");
      
      // If already past limit, show notice
      if (currentIndex >= AUTH_LIMIT) {
        contentLimitNotice?.classList.remove("hidden");
        sentinel?.classList.add('hidden');
      } else {
        // Start observing with limit
        if (sentinel) {
          observer.observe(sentinel);
        }
      }
    }
  });

  // Sign in button handler
  signInBtn?.addEventListener("click", async () => {
    const headerLoginBtn = document.getElementById("header-login-button");
    headerLoginBtn?.click();
  });

  // Filtering logic
  const indicator = document.getElementById("filter-indicator");
  const dateText = document.getElementById("filter-date-text");
  const clearBtn = document.getElementById("clear-filter");

  // Timeline Scroll Logic
  window.addEventListener("timeline-jump", (e: any) => {
    const { target, year, month } = e.detail;
    
    if (target === "top") {
      window.scrollTo({ top: 0, behavior: "smooth" });
      return;
    }

    // Find the first thought that matches year/month
    let targetIndex = -1;
    let targetId = "";

    // Iterate through all thoughts to find the first match
    for (let i = 0; i < thoughtsData.length; i++) {
      const date = new Date(thoughtsData[i].originalDate);
      const tYear = date.getFullYear().toString();
      const tMonth = (date.getMonth() + 1).toString();

      if (year && month) {
        if (tYear === year && tMonth == month) {
          targetIndex = i;
          break;
        }
      } else if (year) {
        if (tYear === year) {
          targetIndex = i;
          break;
        }
      }
    }

    if (targetIndex !== -1) {
      // Security check: if target is beyond auth limit for unauthenticated user
      if (!isAuthenticated && targetIndex >= AUTH_LIMIT) {
          // Scroll to the limit notice
          contentLimitNotice?.classList.remove('hidden');
          contentLimitNotice?.scrollIntoView({ behavior: "smooth", block: "center" });
          
          // Add a visual shake effect to emphasize the limit
          const limitContent = contentLimitNotice?.querySelector('.limit-notice-content');
          limitContent?.classList.add('shake-animation');
          setTimeout(() => {
              limitContent?.classList.remove('shake-animation');
          }, 500);
          
          return;
      }

      // If target is beyond current rendered thoughts, load them
      if (targetIndex >= currentIndex) {
        // Show loading state if it's a large jump
        if (targetIndex - currentIndex > 50) {
            loadingIndicator?.classList.remove('hidden');
        }
        
        // Force render up to target + minimal batch
        // We render everything in between to maintain scroll position context
        const endIndex = Math.min(targetIndex + 10, thoughtsData.length);
        const batch = thoughtsData.slice(currentIndex, endIndex);
        
        batch.forEach((thought) => {
          const cardHTML = createThoughtCardHTML(thought);
          timeline?.insertAdjacentHTML('beforeend', cardHTML);
        });

        currentIndex = endIndex;
        
        // Update sentinel/limits
        const maxIndex = isAuthenticated ? thoughtsData.length : AUTH_LIMIT;
        if (currentIndex >= maxIndex) {
          hasReachedLimit = true;
          sentinel?.classList.add('hidden');
          if (!isAuthenticated && currentIndex >= AUTH_LIMIT) {
             contentLimitNotice?.classList.remove('hidden');
          }
        }
        
        loadingIndicator?.classList.add('hidden');
      }

      // Find the element and scroll
      // Since we just added it, it should be in DOM. 
      // We need to identify it. createThoughtCardHTML uses data-date, but multiple have same date.
      // Let's assume we can find it by index or matching date.
      // Better: find the Nth child of timeline.
      
      const cards = timeline?.children;
      if (cards && cards[targetIndex]) {
        cards[targetIndex].scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }
  });
  
  // Scroll Spy for Timeline
  let scrollTimeout: any;
  window.addEventListener("scroll", () => {
    if (scrollTimeout) clearTimeout(scrollTimeout);
    
    scrollTimeout = setTimeout(() => {
        // Find visible thought card
        const cards = document.querySelectorAll(".thought-card");
        let visibleCard: HTMLElement | null = null;
        
        for (const card of cards) {
            const rect = card.getBoundingClientRect();
            if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
                visibleCard = card as HTMLElement;
                break;
            }
        }
        
        // If no top card found (e.g. scrolled past), take the last one that was above
        if (!visibleCard && cards.length > 0) {
             // Simple fallback: check middle of screen
             const middleY = window.innerHeight / 2;
             for (const card of cards) {
                const rect = card.getBoundingClientRect();
                if (rect.top < middleY && rect.bottom > middleY) {
                    visibleCard = card as HTMLElement;
                    break;
                }
             }
        }

        if (visibleCard) {
            const dateStr = visibleCard.getAttribute("data-date");
            if (dateStr) {
                const date = new Date(dateStr);
                const year = date.getFullYear().toString();
                const month = (date.getMonth() + 1).toString();
                
                window.dispatchEvent(new CustomEvent("timeline-scroll-spy", {
                    detail: { year, month }
                }));
            }
        } else if (window.scrollY < 100) {
             window.dispatchEvent(new CustomEvent("timeline-scroll-spy", {
                    detail: { year: null, month: null } // Top
             }));
        }
    }, 100);
  });

  window.addEventListener("filter-date", (e: any) => {
    const selectedDate = e.detail;
    const cards = document.querySelectorAll(
      ".thought-card",
    ) as NodeListOf<HTMLElement>;

    if (selectedDate) {
      indicator?.classList.remove("hidden");
      if (dateText) dateText.textContent = `Filtered by ${selectedDate}`;

      cards.forEach((card) => {
        if (card.dataset.date === selectedDate) {
          card.classList.remove("hidden");
        } else {
          card.classList.add("hidden");
        }
      });
    } else {
      clearFilter();
    }
  });

  clearBtn?.addEventListener("click", clearFilter);

  function clearFilter() {
    indicator?.classList.add("hidden");
    const cards = document.querySelectorAll(
      ".thought-card",
    ) as NodeListOf<HTMLElement>;
    cards.forEach((card) => card.classList.remove("hidden"));
    window.dispatchEvent(new CustomEvent("clear-calendar-selection"));
  }
</script>

<style is:global>
  .hidden {
    display: none !important;
  }
</style>

<style>
  .auth-state {
    min-height: 80vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .spinner {
    width: 48px;
    height: 48px;
    border: 5px solid var(--md-secondary-container);
    border-bottom-color: var(--md-primary);
    border-radius: 50%;
    display: inline-block;
    box-sizing: border-box;
    animation: rotation 1s linear infinite;
  }

  @keyframes rotation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
  }

  .shake-animation {
    animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
  }

  .container {
    max-width: 900px;
    margin: 0 auto;
    padding-top: var(--space-4);
    position: relative; /* For Timeline positioning */
  }

  .main-content {
    min-width: 0;
  }

  .back-link {
    display: inline-flex;
    align-items: center;
    gap: var(--space-1);
    font-size: 0.875rem;
    margin-bottom: var(--space-4);
    color: var(--md-on-surface-variant);
    text-decoration: none;
  }

  .back-link:hover {
    color: var(--md-primary);
  }

  .back-link .material-symbols-outlined {
    font-size: 1.125rem;
  }

  .hero {
    margin-bottom: var(--space-10);
  }

  .hero h1 {
    font-size: 2.5rem;
    margin-bottom: var(--space-3);
  }

  .hero-subtitle {
    font-size: 1.125rem;
    max-width: 600px;
  }

  .auth-notice {
    margin-top: var(--space-4);
    padding: var(--space-3) var(--space-4);
    background: var(--md-secondary-container);
    color: var(--md-on-secondary-container);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
  }

  .auth-notice p {
    margin: 0;
  }

  .activity-section {
    margin-bottom: var(--space-8);
  }

  .timeline-section {
    margin-bottom: var(--space-10);
  }

  .section-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--md-on-surface-variant);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-4);
  }

  .timeline-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--space-4);
  }

  .filter-badge {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-1) var(--space-3);
    background: var(--md-secondary-container);
    color: var(--md-on-secondary-container);
    border-radius: var(--radius-full);
    font-size: 0.75rem;
    font-weight: 500;
  }

  .filter-badge button {
    background: none;
    border: none;
    color: inherit;
    cursor: pointer;
    font-size: 1rem;
    display: flex;
    align-items: center;
  }

  .filter-badge button:hover {
    opacity: 0.7;
  }

  .timeline {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  .empty-state {
    text-align: center;
    padding: var(--space-12);
    background: var(--md-surface-container-low);
    border-radius: var(--radius-lg);
    border: 1px dashed var(--md-outline-variant);
  }

  .empty-icon {
    font-size: 3rem;
    display: block;
    margin-bottom: var(--space-4);
    opacity: 0.5;
  }

  .content-limit-notice {
    margin-top: var(--space-8);
    padding: var(--space-10) var(--space-6);
    background: linear-gradient(135deg, var(--md-primary-container) 0%, var(--md-secondary-container) 100%);
    border-radius: var(--radius-xl);
    border: 2px solid var(--md-primary);
    text-align: center;
  }

  .limit-notice-content {
    max-width: 500px;
    margin: 0 auto;
  }

  .limit-icon {
    font-size: 4rem;
    color: var(--md-primary);
    margin-bottom: var(--space-4);
    display: inline-block;
  }

  .content-limit-notice h3 {
    font-size: 1.75rem;
    font-weight: 600;
    margin-bottom: var(--space-3);
    color: var(--md-on-primary-container);
  }

  .content-limit-notice p {
    font-size: 1.125rem;
    line-height: 1.6;
    color: var(--md-on-secondary-container);
    margin-bottom: var(--space-6);
  }

  .btn-auth {
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-4) var(--space-8);
    background: var(--md-primary);
    color: var(--md-on-primary);
    border: none;
    border-radius: var(--radius-full);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: var(--shadow-md);
  }

  .btn-auth:hover {
    background: var(--md-primary-container);
    color: var(--md-on-primary-container);
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }

  .btn-auth .material-symbols-outlined {
    font-size: 1.25rem;
  }

  /* Lazy Loading Styles */
  .loading-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-3);
    padding: var(--space-6) 0;
    color: var(--md-on-surface-variant);
  }

  .spinner-small {
    width: 24px;
    height: 24px;
    border: 3px solid var(--md-secondary-container);
    border-bottom-color: var(--md-primary);
    border-radius: 50%;
    animation: rotation 1s linear infinite;
  }

  .load-more-sentinel {
    height: 20px;
    visibility: hidden;
  }

  /* Component Lazy Loading */
  .lazy-load-component {
    position: relative;
    min-height: 100px;
  }

  .component-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-2);
    padding: var(--space-8);
    color: var(--md-on-surface-variant);
    font-size: 0.875rem;
  }

  .component-content {
    transition: opacity 0.3s ease;
  }

  .component-content.hidden {
    opacity: 0;
    height: 0;
    overflow: hidden;
  }
</style>
